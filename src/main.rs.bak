use std::error::Error;

use syn::{parse_quote, Attribute, LitStr, Token, punctuated::Punctuated, Meta, Expr, Lit, ExprLit};


fn main() -> syn::Result<()>{
    let attr1: Attribute = parse_quote! {
        #[mapper(derive=(Debug,Default), map=[("username:login",true)], dto="ProfileDto", include_all="true", 
        except=["password", "age"] )]
    };

    let attr2: Attribute = parse_quote! {
        #[mapper(dto="LoginDto" , map=[("username:login",true),("password",true)], look_at="this")]
    };

    let attributes = vec![attr1,attr2];

    for attr in attributes{
        let nested = attr.parse_args_with(Punctuated::<Meta, Token![,]>::parse_terminated)?;
        println!("nested count={:?}",nested.iter().count());
        nested.iter().for_each(|meta| {
            if let Meta::NameValue(metaname) = meta {
                let ident = metaname.path.get_ident().unwrap();
                let keyname = ident.to_string();
                //println!("keyname={}",keyname);

                if let Expr::Lit(expr) =  & metaname.value{
                    if let Lit::Str(lit_str) = & expr.lit{
                        println!("{}={}",keyname,lit_str.value())
                    }
                }

                if let Expr::Array(expr_arr) = & metaname.value{
                    //println!("{} array has {} elements",keyname,expr_arr.elems.iter().clone().count());

                    if keyname.eq_ignore_ascii_case("map"){
                        //map is a vec of tuples such as map=[("f1",true),("f2",false)]
                        let map_tuple = parse_array_of_tuple(expr_arr);
                        println!("{}={:?}",keyname,map_tuple);
                    }
                    else if keyname.eq_ignore_ascii_case("except"){
                        //except is a vec of string such as except=["val1","val2"]
                        let except_arr = parse_array_of_string(expr_arr);
                        println!("{}={:?}",keyname, except_arr);
                    }
                }

                if let Expr::Tuple(tuple_expr) = & metaname.value {
                    println!("keyname {} is Tuple of literal value",keyname);
                    tuple_expr.elems
                    .iter()
                    .for_each(|elem_expr| {
                        expr_namevalue_debugger(&keyname,elem_expr);
                    })
                }

            }
        });
    }//end of for

    Ok(())
}

fn parse_array_of_tuple(expr_arr: &syn::ExprArray) -> Vec<(String,bool)> {
    let mut vec_tuple: Vec<(String,bool)> = Vec::new();

    for elem in expr_arr.elems.iter(){
        if let Expr::Tuple(el_exp) = elem{
            //println!("{} content  is a Tuple",keyname);
            let mut str_val : Option<String> = None;
            let mut flag: Option<bool> = None;
            for content_expr in el_exp.elems.iter(){
                if let Expr::Lit(content_lit) = content_expr{
                    if let Lit::Str(content) = & content_lit.lit{
                        //print!("valueStr={}",content.value());
                        str_val = content.value().into();
                    }

                    if let Lit::Bool(content) = & content_lit.lit{
                        //print!("  valueBool={}",content.value());
                        flag = content.value.into();
                    }
                }
            }

            if(str_val.is_some() && flag.is_some()){
                vec_tuple.push((str_val.unwrap() , flag.unwrap()));
            }   
            //println!("");
        }
    }

    return vec_tuple
}


fn parse_array_of_string(expr_arr: &syn::ExprArray) -> Vec<String> {
    let mut vec_str : Vec<String>  = Vec::new();
    for elem in expr_arr.elems.iter(){
        if let Expr::Lit(lit_expr) = elem{
            //println!("{} content  is a String",keyname);
            if let Lit::Str(content) = & lit_expr.lit{
                //print!("valueStr={}, ",content.value());
                vec_str.push(content.value());
            }

        }
    }
   return vec_str
}




pub fn expr_namevalue_debugger(attr_name: &str, expr : &Expr){
    match expr {
        Expr::Array(_) => println!("Expression for {} is Array",attr_name),
        Expr::Assign(_) => println!("Expression for {} is Assign",attr_name),
        Expr::Async(_) => println!("Expression for {} is Async",attr_name),
        Expr::Await(_) => println!("Expression for {} is Await",attr_name),
        Expr::Binary(_) => println!("Expression for {} is Binary",attr_name),
        Expr::Block(_) => println!("Expression for {} is Block",attr_name),
        Expr::Break(_) => println!("Expression for {} is Break",attr_name),
        Expr::Call(_) => println!("Expression for {} is Call",attr_name),
        Expr::Cast(_) => println!("Expression for {} is Cast",attr_name),
        Expr::Closure(_) => println!("Expression for {} is Closure",attr_name),
        Expr::Const(_) => println!("Expression for {} is Const",attr_name),
        Expr::Continue(_) => println!("Expression for {} is Continue",attr_name),
        Expr::Field(_) => println!("Expression for {} is Field",attr_name),
        Expr::ForLoop(_) => println!("Expression for {} is ForLoop",attr_name),
        Expr::Group(_) => println!("Expression for {} is Group",attr_name),
        Expr::If(_) => println!("Expression for {} is If",attr_name),
        Expr::Index(_) => println!("Expression for {} is Index",attr_name),
        Expr::Infer(_) => println!("Expression for {} is Infer",attr_name),
        Expr::Let(_) => println!("Expression for {} is Let",attr_name),
        Expr::Lit(_) => println!("Expression for {} is Lit",attr_name),
        Expr::Loop(_) => println!("Expression for {} is Loop",attr_name),
        Expr::Macro(_) => println!("Expression for {} is Macro",attr_name),
        Expr::Match(_) => println!("Expression for {} is Match",attr_name),
        Expr::MethodCall(_) => println!("Expression for {} is MethodCall",attr_name),
        Expr::Paren(_) => println!("Expression for {} is Paren",attr_name),
        Expr::Path(_path_expr) => {
            println!("Expression for {} is Path",attr_name)
        },
        Expr::Range(_) => println!("Expression for {} is Range",attr_name),
        Expr::Reference(_) => println!("Expression for {} is Reference",attr_name),
        Expr::Repeat(_) => println!("Expression for {} is Repeat",attr_name),
        Expr::Return(_) => println!("Expression for {} is Return",attr_name),
        Expr::Struct(_) => println!("Expression for {} is Struct",attr_name),
        Expr::Try(_) => println!("Expression for {} is Try",attr_name),
        Expr::TryBlock(_) => println!("Expression for {} is TryBlock",attr_name),
        Expr::Tuple(_) => println!("Expression for {} is Tuple",attr_name),
        Expr::Unary(_) => println!("Expression for {} is Unary",attr_name),
        Expr::Unsafe(_) => println!("Expression for {} is Unsafe",attr_name),
        Expr::Verbatim(_) => println!("Expression for {} is Verbatim",attr_name),
        Expr::While(_) => println!("Expression for {} is While",attr_name),
        Expr::Yield(_) => println!("Expression for {} is Yield",attr_name),
        _ => println!("Expression for {} is None",attr_name),
        /*Expr::Tuple(ExprTuple) =>{
            println!("Expression for {} is Field",attr_name);
        }
        _ => println!("Expression is not field for {}",attr_name)*/
    }
}
